// Generic классы


//---------------------------------------------

// Введение в Генерики
// Генерики позволяют создавать компоненты, способные работать с любыми типами данных.
// В классах генерики используются для создания универсальных структур данных.
// Пример: Класс Response
// Создание универсального класса Response, где D — тип данных, E — тип ошибки.
// Конструктор принимает данные (D) и ошибку (E), которые могут быть необязательными.
// Важность проверки данных на undefined перед присвоением, чтобы соответствовать строгим настройкам TypeScript (exactOptionalPropertyTypes).
// Пример использования:
// const response = new Response<string, number>(data, errorCode);
// Если типы не указаны явно, TypeScript пытается вывести их самостоятельно. Отсутствие данных приведёт к типу unknown.
// Наследование с Генериками
// Пример создания класса HTTPResponse, наследующего Response, с дополнительным свойством code типа number.
// Наследование от класса с генерика ми требует явного указания типов для D и E.
// Возможность добавления дополнительных генериков в наследуемом классе для дополнительной гибкости.
// class HTTPResponse extends Response<string, number> {
//   // дополнительные методы и свойства
// }
// Полезность Генериков в Классах
// Гибкость: Генерики позволяют классам быть более гибкими, работая с любыми типами данных.
// Повторное использование кода: Можно использовать один и тот же класс для разных типов данных без изменения кода класса.

//---------------------------------------------


class Resp_78<D,E> {
    data?: D;
    error?: E;

    constructor(data?: D, error?: E) {
        if(data) {
            this.data = data;
        }
        if(error) {
            this.error = error;
        }
    }
}

const res_78 = new Resp_78<string, number>('data');

class HTTPResp<F> extends Resp_78<string, number> {
    code!: F;

    setCode(code: F) {
        this.code = code;    
    }
}

const res2 = new HTTPResp()