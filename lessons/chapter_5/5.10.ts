// Копозиция vs Наследования

//--------------------------------

// Введение
// Наследование и композиция являются основными инструментами для структурирования классов и объектов.
// Наследование следует применять аккуратно.
// Пример использования наследования
// Наследование от массива для создания класса пользователей:
// Это позволяет наследовать методы массива и добавлять собственные методы в класс.
// Может привести к неочевидному поведению стандартных методов, таких как toString.
// Проблемы наследования
// Смешивание бизнес-логики с утилитарными классами.
// Наследование может привести к наследованию лишних методов или свойств.
// Трудности при переопределении стандартных методов для достижения необходимого поведения.
// Преимущества композиции
// Позволяет создавать классы, комбинируя различные объекты без жесткой связи между ними.
// Упрощает код, делая его более модульным и уменьшая связанность.
// Обеспечивает большую гибкость в управлении составляющими классов.
// Пример использования композиции
// Создание класса пользователя с платежами:
// Композиция позволяет соединить объекты пользователей и платежей без жесткого смешивания их свойств и методов.
// Обеспечивает четкое разграничение предметных областей и упрощает дальнейшую разработку и поддержку кода.

//--------------------------------

class User_510 {
    name: string;


    constructor(name: string) {
        this.name = name;

    }

}

class Users_510 extends Array<User_510> {
    searchByName(name: string) {
        return this.filter(u => u.name === name);
    }

    override toString():string {
        return this.map(u => u.name).join(', ')
    }
}

const users_510 = new Users_510();

users_510.push(new User_510('Вася'));
console.log(users_510.toString());


class UserList_510 {
    users: User_510[];
    push(u:User_510) {
        this.users.push(u);
    }
}

class Payment_510 {
    date: Date;
}

class UserWithPayment_510 extends Payment_510 {
    name: string;
}

class UserWithPayment_510_2 {
    user: User_510;
    payment: Payment_510;

    constructor(user: User_510, payment: Payment_510) {
        this.payment = payment;
        this.user = user;
    }
}