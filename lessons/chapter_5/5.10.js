"use strict";
// Копозиция vs Наследования
//--------------------------------
// Введение
// Наследование и композиция являются основными инструментами для структурирования классов и объектов.
// Наследование следует применять аккуратно.
// Пример использования наследования
// Наследование от массива для создания класса пользователей:
// Это позволяет наследовать методы массива и добавлять собственные методы в класс.
// Может привести к неочевидному поведению стандартных методов, таких как toString.
// Проблемы наследования
// Смешивание бизнес-логики с утилитарными классами.
// Наследование может привести к наследованию лишних методов или свойств.
// Трудности при переопределении стандартных методов для достижения необходимого поведения.
// Преимущества композиции
// Позволяет создавать классы, комбинируя различные объекты без жесткой связи между ними.
// Упрощает код, делая его более модульным и уменьшая связанность.
// Обеспечивает большую гибкость в управлении составляющими классов.
// Пример использования композиции
// Создание класса пользователя с платежами:
// Композиция позволяет соединить объекты пользователей и платежей без жесткого смешивания их свойств и методов.
// Обеспечивает четкое разграничение предметных областей и упрощает дальнейшую разработку и поддержку кода.
//--------------------------------
class User_510 {
    constructor(name) {
        this.name = name;
    }
}
class Users_510 extends Array {
    searchByName(name) {
        return this.filter(u => u.name === name);
    }
    toString() {
        return this.map(u => u.name).join(', ');
    }
}
const users_510 = new Users_510();
users_510.push(new User_510('Вася'));
console.log(users_510.toString());
class UserList_510 {
    push(u) {
        this.users.push(u);
    }
}
class Payment_510 {
}
class UserWithPayment_510 extends Payment_510 {
}
class UserWithPayment_510_2 {
    constructor(user, payment) {
        this.payment = payment;
        this.user = user;
    }
}
